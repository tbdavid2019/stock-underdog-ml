"""
Database management for stock prediction application.
Currently supports MySQL and MongoDB. Will be migrated to Supabase in Phase 2.
"""
import datetime
import os
from contextlib import contextmanager
try:
    import mysql.connector
    from mysql.connector import Error, pooling
    HAS_MYSQL = True
except ImportError:
    HAS_MYSQL = False

try:
    from pymongo import MongoClient
    HAS_MONGO = True
except ImportError:
    HAS_MONGO = False

try:
    from supabase import create_client, Client
    HAS_SUPABASE = True
except ImportError:
    HAS_SUPABASE = False

from typing import List, Tuple, Optional, Any
from config import DatabaseConfig, config
from logger import logger



class SupabaseManager:
    """Manager for Supabase connection and operations"""
    
    def __init__(self):
        self.enabled = False
        url = config.supabase_url
        
        # Prioritize service_role key (full admin access) over publishable key
        key = os.getenv("SUPABASE_SERVICE_KEY") or config.supabase_key
        
        if not HAS_SUPABASE:
            logger.warning("âš  è­¦å‘Š: æœªå®‰è£ supabase å¥—ä»¶")
            return
            
        if not url or not key:
            logger.warning("âš  è­¦å‘Š: Supabase URL æˆ– Key æœªè¨­å®š")
            return
            
        try:
            self.client: Client = create_client(url, key)
            self.enabled = True
            logger.info("Supabase é€£æ¥åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            logger.error(f"Supabase é€£ç·šå¤±æ•—: {str(e)}")
            self.enabled = False

    def save_predictions(self, index_name: str, predictions: List[Tuple], model_name: str, period: str):
        """
        Save prediction results to Supabase 'predictions' table
        
        Args:
            index_name: Name of stock index (e.g., 'å°ç£50')
            predictions: List of tuples (ticker, potential, current, predicted)
            model_name: Name of the model (e.g., 'LSTM')
            period: Training period (e.g., '6mo')
        """
        if not self.enabled:
            return

        data = []
        timestamp = datetime.datetime.now().isoformat()
        
        for p in predictions:
            # p format: (ticker, potential, current_price, predicted_price)
            # Handle pandas types if necessary
            import pandas as pd
            tk = p[0]
            pot = float(p[1].iloc[0]) if isinstance(p[1], pd.Series) else float(p[1])
            cur = float(p[2].iloc[0]) if isinstance(p[2], pd.Series) else float(p[2])
            pred = float(p[3].iloc[0]) if isinstance(p[3], pd.Series) else float(p[3])

            record = {
                "index_name": index_name,
                "model_name": model_name,
                "ticker": tk,
                "potential": pot,
                "current_price": cur,
                "predicted_price": pred,
                "period": period,
                "timestamp": timestamp
            }
            data.append(record)
            
        try:
            # Perform batch insert
            self.client.table("predictions").insert(data).execute()
            logger.info(f"âœ… æˆåŠŸå¯«å…¥ {len(data)} ç­†é æ¸¬çµæœåˆ° Supabase (Model: {model_name})")
        except Exception as e:
            logger.error(f"âŒ Supabase å¯«å…¥å¤±æ•—: {str(e)}")
            if "relation" in str(e) and "does not exist" in str(e):
                 logger.warning("ğŸ’¡ æç¤º: è«‹ç¢ºèªæ‚¨çš„ Supabase è³‡æ–™åº«ä¸­å·²å»ºç«‹ 'predictions' è³‡æ–™è¡¨ã€‚")
                 print("   æ‚¨å¯ä»¥åœ¨ SQL Editor åŸ·è¡Œä»¥ä¸‹æŒ‡ä»¤:")
                 print("   CREATE TABLE predictions (")
                 print("       id bigint generated by default as identity primary key,")
                 print("       created_at timestamp with time zone default timezone('utc'::text, now()) not null,")
                 print("       index_name text, model_name text, ticker text,")
                 print("       current_price numeric, predicted_price numeric, potential numeric,")
                 print("       period text, timestamp timestamp with time zone")
                 print("   );")

    def save_dual_strategy_results(self, index_name: str, results: dict, period: str = "6mo"):
        """
        ä¿å­˜é›™è»Œç­–ç•¥çµæœåˆ° Supabase predictions è¡¨æ ¼ï¼ˆåŸè¡¨æ“´å±•ç‰ˆï¼‰
        
        Args:
            index_name: æŒ‡æ•¸åç¨±
            results: åŒ…å« xuantie_results, lstm_results, overlap_results
            period: æ•¸æ“šé€±æœŸ
        
        éœ€è¦å…ˆåŸ·è¡Œ supabase_add_columns.sql æ“´å±• predictions è¡¨æ ¼ï¼š
        - strategy_type: ç­–ç•¥é¡å‹
        - ma5, ma10, ma60, ma120, ma250: å‡ç·šæŒ‡æ¨™
        - pullback_type: å›èª¿é¡å‹
        - pe, pb, forward_pe, ev_ebitda: åŸºæœ¬é¢æ•¸æ“š
        """
        if not self.enabled:
            return
        
        import pandas as pd
        timestamp = datetime.datetime.now().isoformat()
        
        all_data = []
        
        # 1. ä¿å­˜ç„éµç­–ç•¥çµæœ
        xuantie_df = results.get('xuantie_results', pd.DataFrame())
        if not xuantie_df.empty:
            for idx, row in xuantie_df.iterrows():
                record = {
                    "index_name": index_name,
                    "model_name": "ç„éµé‡åŠ",  # ä¿æŒå‘å¾Œå…¼å®¹
                    "strategy_type": "ç„éµé‡åŠ",
                    "ticker": row['ticker'],
                    "current_price": float(row['current_price']),
                    "predicted_price": None,
                    "potential": None,
                    "ma5": float(row.get('ma5')) if row.get('ma5') and not pd.isna(row.get('ma5')) else None,
                    "ma10": float(row.get('ma10')) if row.get('ma10') and not pd.isna(row.get('ma10')) else None,
                    "ma60": float(row.get('ma60')) if row.get('ma60') and not pd.isna(row.get('ma60')) else None,
                    "ma120": float(row.get('ma120')) if row.get('ma120') and not pd.isna(row.get('ma120')) else None,
                    "ma250": float(row.get('ma250')) if row.get('ma250') and not pd.isna(row.get('ma250')) else None,
                    "pullback_type": row.get('pullback_type'),
                    "pe": float(row.get('pe')) if row.get('pe') and not pd.isna(row.get('pe')) else None,
                    "pb": float(row.get('pb')) if row.get('pb') and not pd.isna(row.get('pb')) else None,
                    "forward_pe": float(row.get('forward_pe')) if row.get('forward_pe') and not pd.isna(row.get('forward_pe')) else None,
                    "ev_ebitda": float(row.get('ev_ebitda')) if row.get('ev_ebitda') and not pd.isna(row.get('ev_ebitda')) else None,
                    "period": period,
                    "timestamp": timestamp
                }
                all_data.append(record)
        
        # 2. ä¿å­˜ LSTM é æ¸¬çµæœ
        lstm_results = results.get('lstm_results', [])
        for result in lstm_results:
            record = {
                "index_name": index_name,
                "model_name": "LSTM",  # ä¿æŒå‘å¾Œå…¼å®¹
                "strategy_type": "LSTMé æ¸¬",
                "ticker": result['ticker'],
                "current_price": float(result['current_price']),
                "predicted_price": float(result['predicted_price']),
                "potential": float(result['potential']),
                "ma5": None,
                "ma10": None,
                "ma60": None,
                "ma120": None,
                "ma250": None,
                "pullback_type": None,
                "pe": float(result.get('pe')) if result.get('pe') and not pd.isna(result.get('pe')) else None,
                "pb": float(result.get('pb')) if result.get('pb') and not pd.isna(result.get('pb')) else None,
                "forward_pe": float(result.get('forward_pe')) if result.get('forward_pe') and not pd.isna(result.get('forward_pe')) else None,
                "ev_ebitda": float(result.get('ev_ebitda')) if result.get('ev_ebitda') and not pd.isna(result.get('ev_ebitda')) else None,
                "period": period,
                "timestamp": timestamp
            }
            all_data.append(record)
        
        # 3. ä¿å­˜é›™é‡ç¬¦åˆçµæœ
        overlap_df = results.get('overlap_results', pd.DataFrame())
        if not overlap_df.empty:
            for idx, row in overlap_df.iterrows():
                record = {
                    "index_name": index_name,
                    "model_name": "é›™é‡ç¬¦åˆ",  # ä¿æŒå‘å¾Œå…¼å®¹
                    "strategy_type": "é›™é‡ç¬¦åˆ",
                    "ticker": row['ticker'],
                    "current_price": float(row['current_price']),
                    "predicted_price": float(row['predicted_price']),
                    "potential": float(row['lstm_potential']),
                    "ma5": float(row.get('ma5')) if row.get('ma5') and not pd.isna(row.get('ma5')) else None,
                    "ma10": float(row.get('ma10')) if row.get('ma10') and not pd.isna(row.get('ma10')) else None,
                    "ma60": float(row.get('ma60')) if row.get('ma60') and not pd.isna(row.get('ma60')) else None,
                    "ma120": float(row.get('ma120')) if row.get('ma120') and not pd.isna(row.get('ma120')) else None,
                    "ma250": float(row.get('ma250')) if row.get('ma250') and not pd.isna(row.get('ma250')) else None,
                    "pullback_type": row.get('pullback_type'),
                    "pe": float(row.get('pe')) if row.get('pe') and not pd.isna(row.get('pe')) else None,
                    "pb": float(row.get('pb')) if row.get('pb') and not pd.isna(row.get('pb')) else None,
                    "forward_pe": float(row.get('forward_pe')) if row.get('forward_pe') and not pd.isna(row.get('forward_pe')) else None,
                    "ev_ebitda": float(row.get('ev_ebitda')) if row.get('ev_ebitda') and not pd.isna(row.get('ev_ebitda')) else None,
                    "period": period,
                    "timestamp": timestamp
                }
                all_data.append(record)
        
        if not all_data:
            logger.info("âš ï¸ ç„¡æ•¸æ“šéœ€è¦ä¿å­˜åˆ° Supabase")
            return
        
        try:
            # å¯«å…¥ predictions è¡¨æ ¼ï¼ˆåŸè¡¨æ“´å±•ç‰ˆï¼‰
            self.client.table("predictions").insert(all_data).execute()
            logger.info(f"âœ… æˆåŠŸå¯«å…¥ {len(all_data)} ç­†é›™è»Œç­–ç•¥çµæœåˆ° Supabase predictions è¡¨")
            
            # çµ±è¨ˆå„ç­–ç•¥æ•¸é‡
            strategy_counts = {}
            for record in all_data:
                st = record.get('strategy_type', 'Unknown')
                strategy_counts[st] = strategy_counts.get(st, 0) + 1
            
            for strategy, count in strategy_counts.items():
                logger.info(f"   â”œâ”€ {strategy}: {count} ç­†")
                
        except Exception as e:
            logger.error(f"âŒ Supabase å¯«å…¥å¤±æ•—: {str(e)}")
            if "column" in str(e).lower() and "does not exist" in str(e).lower():
                logger.warning("ğŸ’¡ è«‹åœ¨ Supabase SQL Editor åŸ·è¡Œ supabase_add_columns.sql")
                logger.warning("   é€™æœƒåœ¨ predictions è¡¨æ ¼æ–°å¢: strategy_type, ma5, ma10, ma60, ma120, ma250, pullback_type, pe, pb, forward_pe, ev_ebitda")
            elif "relation" in str(e) and "does not exist" in str(e):
                logger.warning("ğŸ’¡ è«‹åœ¨ Supabase SQL Editor åŸ·è¡Œ supabase_schema.sql å»ºç«‹ predictions è¡¨æ ¼")
                logger.warning("ğŸ’¡ è«‹åœ¨ Supabase SQL Editor åŸ·è¡Œå»ºè¡¨æŒ‡ä»¤ (è¦‹ docstring)")


class MySQLManager:
    """
    MySQL database manager for stock predictions.
    Note: This will be replaced with Supabase in Phase 2.
    """
    
    def __init__(self):
        self.enabled = DatabaseConfig.USE_MYSQL and HAS_MYSQL
        self.connection = None
        if not HAS_MYSQL and DatabaseConfig.USE_MYSQL:
            print("âš  è­¦å‘Š: æœªå®‰è£ MySQL é€£æ¥å™¨ï¼ŒMySQL åŠŸèƒ½å·²åœç”¨")
            
        if not self.enabled:
            # print("MySQL åŠŸèƒ½æœªå•Ÿç”¨")
            return
            
        try:
            print("å˜—è©¦é€£æ¥ MySQL...")
            print(f"Host: {DatabaseConfig.MYSQL_HOST}")
            print(f"Database: {DatabaseConfig.MYSQL_DATABASE}")
            
            self.connection = mysql.connector.connect(
                host=DatabaseConfig.MYSQL_HOST,
                user=DatabaseConfig.MYSQL_USER,
                password=DatabaseConfig.MYSQL_PASSWORD,
                database=DatabaseConfig.MYSQL_DATABASE,
                port=DatabaseConfig.MYSQL_PORT
            )
            print("MySQL é€£æ¥æˆåŠŸ")
            self.create_prediction_table()
            
        except Error as e:
            print(f"MySQL é€£æ¥éŒ¯èª¤: {e}")
            self.connection = None
            self.enabled = False
    
    def create_prediction_table(self):
        """Create stock_predictions table if it doesn't exist"""
        if not self.enabled or not self.connection:
            return
        
        try:
            cursor = self.connection.cursor()
            
            # Check if table exists
            check_table_query = """
            SELECT COUNT(*)
            FROM information_schema.tables
            WHERE table_schema = %s
            AND table_name = 'stock_predictions'
            """
            cursor.execute(check_table_query, (DatabaseConfig.MYSQL_DATABASE,))
            table_exists = cursor.fetchone()[0] > 0
            
            if table_exists:
                print("stock_predictions è¡¨å·²å­˜åœ¨ï¼Œè·³éå‰µå»º")
            else:
                # Create table
                create_table_query = """
                CREATE TABLE IF NOT EXISTS stock_predictions (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    calculation_date DATE,
                    calculation_time TIME,
                    index_name VARCHAR(50),
                    stock_symbol VARCHAR(20),
                    current_price DECIMAL(10,2),
                    predicted_price DECIMAL(10,2),
                    potential DECIMAL(10,4),
                    prediction_method VARCHAR(20),
                    period_param VARCHAR(10),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                """
                cursor.execute(create_table_query)
                self.connection.commit()
                print("æˆåŠŸå‰µå»º stock_predictions è¡¨")
        
        except Error as e:
            print(f"æª¢æŸ¥/å‰µå»ºè¡¨æ ¼æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        finally:
            cursor.close()
    
    def save_predictions(
        self, 
        index_name: str, 
        predictions: List[Tuple[str, float, float, float]], 
        method: str, 
        period: str
    ):
        """
        Save predictions to MySQL database
        
        Args:
            index_name: Name of the stock index (e.g., "SP500")
            predictions: List of tuples (ticker, potential, current_price, predicted_price)
            method: Prediction method name (e.g., "LSTM", "Prophet")
            period: Time period used for prediction
        """
        if not self.enabled or not self.connection:
            return
        
        try:
            cursor = self.connection.cursor()
            current_date = datetime.datetime.now().date()
            current_time = datetime.datetime.now().time()
            
            insert_query = """
            INSERT INTO stock_predictions 
            (calculation_date, calculation_time, index_name, stock_symbol, 
             current_price, predicted_price, potential, prediction_method, period_param)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            for ticker, potential, current_price, predicted_price in predictions:
                # Handle pandas Series conversion
                import pandas as pd
                data = (
                    current_date,
                    current_time,
                    index_name,
                    ticker,
                    float(current_price.iloc[0]) if isinstance(current_price, pd.Series) else float(current_price),
                    float(predicted_price.iloc[0]) if isinstance(predicted_price, pd.Series) else float(predicted_price),
                    float(potential.iloc[0]) if isinstance(potential, pd.Series) else float(potential),
                    method,
                    period
                )
                cursor.execute(insert_query, data)
            
            self.connection.commit()
            print(f"æˆåŠŸä¿å­˜ {len(predictions)} æ¢ {method} é æ¸¬çµæœåˆ° MySQL")
        
        except Error as e:
            print(f"ä¿å­˜åˆ° MySQL æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        finally:
            cursor.close()
    
    def close(self):
        """Close MySQL connection"""
        if self.connection and self.connection.is_connected():
            self.connection.close()
            print("MySQL é€£æ¥å·²é—œé–‰")
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close()


def save_to_mongodb(index_name: str, stock_predictions: dict):
    """
    Save stock predictions to MongoDB
    Note: This will be replaced with Supabase in Phase 2.
    
    Args:
        index_name: Name of the stock index
        stock_predictions: Dictionary of prediction results
    """
    if not HAS_MONGO:
        print("MongoDB åŠŸèƒ½æœªå•Ÿç”¨æˆ–æœªå®‰è£ pymongo")
        return

    client = None
    try:
        client = MongoClient(DatabaseConfig.MONGO_URI)
        db = client[DatabaseConfig.MONGO_DB_NAME]
        collection = db["predictions"]
        
        # Prepare document for insertion
        record = {
            "index": index_name,
            "timestamp": datetime.datetime.now(),
            "predictions": stock_predictions
        }
        
        # Insert into MongoDB
        collection.insert_one(record)
        print(f"æˆåŠŸå°‡ {index_name} çµæœå¯«å…¥ MongoDB")
        
    except Exception as e:
        print(f"âš ï¸ å¯«å…¥ MongoDB å¤±æ•—: {str(e)}")
    finally:
        if client:
            client.close()
