"""
Database management for stock prediction application.
Currently supports MySQL and MongoDB. Will be migrated to Supabase in Phase 2.
"""
import datetime
import os
from contextlib import contextmanager
try:
    import mysql.connector
    from mysql.connector import Error, pooling
    HAS_MYSQL = True
except ImportError:
    HAS_MYSQL = False

try:
    from pymongo import MongoClient
    HAS_MONGO = True
except ImportError:
    HAS_MONGO = False

try:
    from supabase import create_client, Client
    HAS_SUPABASE = True
except ImportError:
    HAS_SUPABASE = False

from typing import List, Tuple, Optional, Any
from config import DatabaseConfig, config
from logger import logger



class SupabaseManager:
    """Manager for Supabase connection and operations"""
    
    def __init__(self):
        self.enabled = False
        url = config.supabase_url
        
        # Prioritize service_role key (full admin access) over publishable key
        key = os.getenv("SUPABASE_SERVICE_KEY") or config.supabase_key
        
        if not HAS_SUPABASE:
            logger.warning("âš  è­¦å‘Š: æœªå®‰è£ supabase å¥—ä»¶")
            return
            
        if not url or not key:
            logger.warning("âš  è­¦å‘Š: Supabase URL æˆ– Key æœªè¨­å®š")
            return
            
        try:
            self.client: Client = create_client(url, key)
            self.enabled = True
            logger.info("Supabase é€£æ¥åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            logger.error(f"Supabase é€£ç·šå¤±æ•—: {str(e)}")
            self.enabled = False

    def save_predictions(self, index_name: str, predictions: List[Tuple], model_name: str, period: str):
        """
        Save prediction results to Supabase 'predictions' table
        
        Args:
            index_name: Name of stock index (e.g., 'å°ç£50')
            predictions: List of tuples (ticker, potential, current, predicted)
            model_name: Name of the model (e.g., 'LSTM')
            period: Training period (e.g., '6mo')
        """
        if not self.enabled:
            return

        data = []
        timestamp = datetime.datetime.now().isoformat()
        
        for p in predictions:
            # p format: (ticker, potential, current_price, predicted_price)
            # Handle pandas types if necessary
            import pandas as pd
            tk = p[0]
            pot = float(p[1].iloc[0]) if isinstance(p[1], pd.Series) else float(p[1])
            cur = float(p[2].iloc[0]) if isinstance(p[2], pd.Series) else float(p[2])
            pred = float(p[3].iloc[0]) if isinstance(p[3], pd.Series) else float(p[3])

            record = {
                "index_name": index_name,
                "model_name": model_name,
                "ticker": tk,
                "potential": pot,
                "current_price": cur,
                "predicted_price": pred,
                "period": period,
                "timestamp": timestamp
            }
            data.append(record)
            
        try:
            # Perform batch insert
            self.client.table("predictions").insert(data).execute()
            logger.info(f"âœ… æˆåŠŸå¯«å…¥ {len(data)} ç­†é æ¸¬çµæœåˆ° Supabase (Model: {model_name})")
        except Exception as e:
            logger.error(f"âŒ Supabase å¯«å…¥å¤±æ•—: {str(e)}")
            if "relation" in str(e) and "does not exist" in str(e):
                 logger.warning("ğŸ’¡ æç¤º: è«‹ç¢ºèªæ‚¨çš„ Supabase è³‡æ–™åº«ä¸­å·²å»ºç«‹ 'predictions' è³‡æ–™è¡¨ã€‚")
                 print("   æ‚¨å¯ä»¥åœ¨ SQL Editor åŸ·è¡Œä»¥ä¸‹æŒ‡ä»¤ï¼š") # Keep SQL instructions as print for copy-paste visibility? Or logger.warning? Logger is better but standard format adds timestamp. Print is cleaner for block copy. I will keep print for SQL block.
                 print("   CREATE TABLE predictions (")
                 print("       id bigint generated by default as identity primary key,")
                 print("       created_at timestamp with time zone default timezone('utc'::text, now()) not null,")
                 print("       index_name text, model_name text, ticker text,")
                 print("       current_price numeric, predicted_price numeric, potential numeric,")
                 print("       period text, timestamp timestamp with time zone")
                 print("   );")


class MySQLManager:
    """
    MySQL database manager for stock predictions.
    Note: This will be replaced with Supabase in Phase 2.
    """
    
    def __init__(self):
        self.enabled = DatabaseConfig.USE_MYSQL and HAS_MYSQL
        self.connection = None
        if not HAS_MYSQL and DatabaseConfig.USE_MYSQL:
            print("âš  è­¦å‘Š: æœªå®‰è£ MySQL é€£æ¥å™¨ï¼ŒMySQL åŠŸèƒ½å·²åœç”¨")
            
        if not self.enabled:
            # print("MySQL åŠŸèƒ½æœªå•Ÿç”¨")
            return
            
        try:
            print("å˜—è©¦é€£æ¥ MySQL...")
            print(f"Host: {DatabaseConfig.MYSQL_HOST}")
            print(f"Database: {DatabaseConfig.MYSQL_DATABASE}")
            
            self.connection = mysql.connector.connect(
                host=DatabaseConfig.MYSQL_HOST,
                user=DatabaseConfig.MYSQL_USER,
                password=DatabaseConfig.MYSQL_PASSWORD,
                database=DatabaseConfig.MYSQL_DATABASE,
                port=DatabaseConfig.MYSQL_PORT
            )
            print("MySQL é€£æ¥æˆåŠŸ")
            self.create_prediction_table()
            
        except Error as e:
            print(f"MySQL é€£æ¥éŒ¯èª¤: {e}")
            self.connection = None
            self.enabled = False
    
    def create_prediction_table(self):
        """Create stock_predictions table if it doesn't exist"""
        if not self.enabled or not self.connection:
            return
        
        try:
            cursor = self.connection.cursor()
            
            # Check if table exists
            check_table_query = """
            SELECT COUNT(*)
            FROM information_schema.tables
            WHERE table_schema = %s
            AND table_name = 'stock_predictions'
            """
            cursor.execute(check_table_query, (DatabaseConfig.MYSQL_DATABASE,))
            table_exists = cursor.fetchone()[0] > 0
            
            if table_exists:
                print("stock_predictions è¡¨å·²å­˜åœ¨ï¼Œè·³éå‰µå»º")
            else:
                # Create table
                create_table_query = """
                CREATE TABLE IF NOT EXISTS stock_predictions (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    calculation_date DATE,
                    calculation_time TIME,
                    index_name VARCHAR(50),
                    stock_symbol VARCHAR(20),
                    current_price DECIMAL(10,2),
                    predicted_price DECIMAL(10,2),
                    potential DECIMAL(10,4),
                    prediction_method VARCHAR(20),
                    period_param VARCHAR(10),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                """
                cursor.execute(create_table_query)
                self.connection.commit()
                print("æˆåŠŸå‰µå»º stock_predictions è¡¨")
        
        except Error as e:
            print(f"æª¢æŸ¥/å‰µå»ºè¡¨æ ¼æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        finally:
            cursor.close()
    
    def save_predictions(
        self, 
        index_name: str, 
        predictions: List[Tuple[str, float, float, float]], 
        method: str, 
        period: str
    ):
        """
        Save predictions to MySQL database
        
        Args:
            index_name: Name of the stock index (e.g., "SP500")
            predictions: List of tuples (ticker, potential, current_price, predicted_price)
            method: Prediction method name (e.g., "LSTM", "Prophet")
            period: Time period used for prediction
        """
        if not self.enabled or not self.connection:
            return
        
        try:
            cursor = self.connection.cursor()
            current_date = datetime.datetime.now().date()
            current_time = datetime.datetime.now().time()
            
            insert_query = """
            INSERT INTO stock_predictions 
            (calculation_date, calculation_time, index_name, stock_symbol, 
             current_price, predicted_price, potential, prediction_method, period_param)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            for ticker, potential, current_price, predicted_price in predictions:
                # Handle pandas Series conversion
                import pandas as pd
                data = (
                    current_date,
                    current_time,
                    index_name,
                    ticker,
                    float(current_price.iloc[0]) if isinstance(current_price, pd.Series) else float(current_price),
                    float(predicted_price.iloc[0]) if isinstance(predicted_price, pd.Series) else float(predicted_price),
                    float(potential.iloc[0]) if isinstance(potential, pd.Series) else float(potential),
                    method,
                    period
                )
                cursor.execute(insert_query, data)
            
            self.connection.commit()
            print(f"æˆåŠŸä¿å­˜ {len(predictions)} æ¢ {method} é æ¸¬çµæœåˆ° MySQL")
        
        except Error as e:
            print(f"ä¿å­˜åˆ° MySQL æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
        finally:
            cursor.close()
    
    def close(self):
        """Close MySQL connection"""
        if self.connection and self.connection.is_connected():
            self.connection.close()
            print("MySQL é€£æ¥å·²é—œé–‰")
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close()


def save_to_mongodb(index_name: str, stock_predictions: dict):
    """
    Save stock predictions to MongoDB
    Note: This will be replaced with Supabase in Phase 2.
    
    Args:
        index_name: Name of the stock index
        stock_predictions: Dictionary of prediction results
    """
    if not HAS_MONGO:
        print("MongoDB åŠŸèƒ½æœªå•Ÿç”¨æˆ–æœªå®‰è£ pymongo")
        return

    client = None
    try:
        client = MongoClient(DatabaseConfig.MONGO_URI)
        db = client[DatabaseConfig.MONGO_DB_NAME]
        collection = db["predictions"]
        
        # Prepare document for insertion
        record = {
            "index": index_name,
            "timestamp": datetime.datetime.now(),
            "predictions": stock_predictions
        }
        
        # Insert into MongoDB
        collection.insert_one(record)
        print(f"æˆåŠŸå°‡ {index_name} çµæœå¯«å…¥ MongoDB")
        
    except Exception as e:
        print(f"âš ï¸ å¯«å…¥ MongoDB å¤±æ•—: {str(e)}")
    finally:
        if client:
            client.close()
